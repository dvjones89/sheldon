#!/usr/bin/env ruby
require "thor"
require "tty-prompt"
require_relative "../lib/sheldon"

module CLI
  class Sheldon < Thor
    map link: :recall
    map ls: :list
    map "-v" => :version
    map "--version" => :version

    class_option :debug, :desc => "Print errors and backtraces to the console for debugging."

    desc "build path", "Tell Sheldon to build all config_ files in a directory to single master config"
    def build(rel_path_to_target)
      abs_build_path = File.expand_path(rel_path_to_target)
      with_exception_handling do
        announce("Built #{File.basename(rel_path_to_target)}") if sheldon.build(abs_build_path)
      end
    end

    desc "forget recall_cue", "Remove file/folder from Sheldon's brain"
    def forget(recall_cue=nil)
      recall_cue ||= cue_picker("What would you like to forget?")
      with_exception_handling { sheldon.forget(recall_cue) }
      announce("I've forgotten about #{recall_cue}. Let us never mention it again.")
    end

    desc "learn path_to_target", "Add a new file/folder to Sheldon's brain. Supply a recall_cue at runtime."
    def learn(rel_path_to_target)
      abs_learn_path = File.expand_path(rel_path_to_target)
      default_cue = File.basename(rel_path_to_target)
      recall_cue = prompt.ask("Recall Cue For File/Folder", default: default_cue, required: true)
      with_exception_handling { sheldon.learn(recall_cue, abs_learn_path) }
      with_exception_handling { sheldon.recall(recall_cue) }
    end

    desc "list", "List all recall cues known by Sheldon"
    def list
      sheldon.list_cues.each do |recall_cue|
        sheldon.recalled?(recall_cue) ? prompt.say(recall_cue, color: :green) : prompt.say(recall_cue, color: :red)
      end
    end

    desc "open recall_cue", "Open your file/folder contents in your default editor"
    def open(recall_cue=nil)
      editor = ENV['EDITOR']
      error_and_exit("Your system does not define a default editor. Please set $EDITOR and try again.") if editor.nil?
      recall_cue ||= cue_picker("What would you like to open?")

      with_exception_handling do
        error_and_exit("#{recall_cue} has not been recalled on this computer. Use `sheldon recall #{recall_cue}` and then try again.") unless sheldon.recalled?(recall_cue)
        memory_entry = sheldon.brain.memory.recall(recall_cue)
        filepath = add_home(memory_entry[:filepath])
        system("#{editor} '#{filepath}'")
      end
    end

    desc "recall recall_cue", "Recall a previously learnt file/directory to it's original location on the filesystem.\nUse `sheldon list` for available cues."
    option :i, type: :boolean, desc: "Interactive mode - prompts Y/N for each available recall_cue"

    def recall(recall_cue=nil)
      if options[:i]
        sheldon.list_cues.each do |recall_cue|
          answer = prompt.yes?("Recall #{recall_cue}?")
          with_exception_handling { sheldon.recall(recall_cue) if answer.downcase == "y" }
        end
      else
        recall_cue ||= cue_picker("What would you like to recall?")
        with_exception_handling { sheldon.recall(recall_cue) }
      end

      announce("Recall Complete.")
    end

    desc "setup path_to_data_directory", "Setup Sheldon on this host, supplying the path that where Sheldon's data directory can be found, or should be created."
    def setup(rel_data_path=nil)
      rel_data_path ||= prompt.ask("Please supply location for new/existing data directory", required: true)
      abs_data_path = File.expand_path(rel_data_path)
      with_exception_handling do
        sheldon = ::Sheldon.new(abs_data_path)

        if sheldon.brain.present?
          prompt.ok("Using existing Sheldon database found at #{abs_data_path}.")
        else
          sheldon.setup!
          prompt.ok("New Sheldon database created at #{abs_data_path}")
        end

        write_to_dotfile("data_directory", sheldon.brain.location)
      end
    end

    desc "version", "Prints the current version of Sheldon"
    def version
      announce ::Sheldon::VERSION
    end

    private

    def announce(message)
      logo = "ðŸ’¥".encode("utf-8")
      puts logo + " Sheldon" + logo + "  #{message}"
    end

    def error_and_exit(message)
      prompt.error(message)
      exit!
    end

    def prompt
      @prompt ||= TTY::Prompt.new(interrupt: :exit)
    end

    def cue_picker(message)
      prompt.select(message, sheldon.list_cues, per_page: 20, filter: true)
    end

    def read_from_dotfile(key)
      dotfile = YAML::Store.new(add_home(".sheldon"))
      dotfile.transaction { dotfile[key] }
    end

    def sheldon
      with_exception_handling { @sheldon ||= ::Sheldon.new(sheldon_data_dir) }
    end

    def sheldon_data_dir
      sheldon_data_dir = read_from_dotfile("data_directory") || ENV['SHELDON_DATA_DIR']
      sheldon_data_dir || error_and_exit("No configuration found. Please run `sheldon setup`")
    end

    def with_exception_handling(&block)
      yield
    rescue Exception => e
      if options[:debug]
        puts ([e.inspect] + e.backtrace).join("\n")
      else
        prompt.error(e.message + "\nUse --debug to print backtrace")
      end
      exit!
    end

    def write_to_dotfile(key, value)
      dotfile = YAML::Store.new(add_home(".sheldon"))
      dotfile.transaction { dotfile[key] = value }
    end

  end
end

CLI::Sheldon.start(ARGV)
