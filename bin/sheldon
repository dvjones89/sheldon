#!/usr/bin/env ruby
require "thor"
require_relative "../lib/sheldon"

module CLI
  class Sheldon < Thor
    map link: :recall
    map ls: :list
    map "-v" => :version
    map "--version" => :version

    class_option :debug, :desc => "Print errors and backtraces to the console for debugging."

    desc "build path", "Tell Sheldon to build all config_ files in a directory to single master config"
    def build(rel_path_to_target)
      abs_build_path = File.expand_path(rel_path_to_target)
      with_exception_handling{ sheldon.build(abs_build_path) }
      announce("Built #{File.basename(rel_path_to_target)}")
    end

    desc "forget recall_cue", "Remove file/folder from Sheldon's brain"
    def forget(recall_cue=nil)
      recall_cue ||= prompt_user("Recall Cue For File/Folder")
      with_exception_handling { sheldon.forget(recall_cue) }
      announce("I've forgotten about #{recall_cue}. Let us never mention it again.")
    end

    desc "learn path", "Add a new file/folder to Sheldon's brain. Supply a recall_cue at runtime."
    def learn(rel_path_to_target)
      abs_learn_path = File.expand_path(rel_path_to_target)
      default_cue = File.basename(rel_path_to_target)
      recall_cue = prompt_user("Recall Cue For File/Folder (#{default_cue})") || default_cue
      with_exception_handling { sheldon.learn(recall_cue, abs_learn_path) }
      with_exception_handling { sheldon.recall(recall_cue) }
    end

    desc "list", "List all recall cues known by Sheldon"
    def list
      sheldon.list_cues.each do |recall_cue|
        sheldon.recalled?(recall_cue) ? green(recall_cue) : red(recall_cue)
      end
    end

    desc "recall recall_cue", "Symlink a previously learnt file/directory to it's original location on the filesystem.\nUse `sheldon list` for available cues."
    option :i, type: :boolean, desc: "Interactive mode - prompts Y/N for each available recall_cue"

    def recall(recall_cue=nil)
      if options[:i]
        sheldon.list_cues.each do |recall_cue|
          answer = prompt_user("Recall #{recall_cue}? (Y/N)")
          with_exception_handling { sheldon.recall(recall_cue) if answer.downcase == "y" }
        end
      else
        recall_cue ||= prompt_user("Recall Cue For File/Folder")
        with_exception_handling { sheldon.recall(recall_cue) }
      end

      announce("Recall Complete.")
    end

    desc "setup path_to_data_directory", "Setup Sheldon on this host, supplying the path that where Sheldon's data directory can be found, or should be created."
    def setup(rel_data_path=nil)
      rel_data_path ||= prompt_user("Please supply location for new/existing data directory")
      abs_data_path = File.expand_path(rel_data_path)
      with_exception_handling do
        sheldon = ::Sheldon.new(abs_data_path)

        if sheldon.brain.present?
          green "Using existing Sheldon database found at #{abs_data_path}."
        else
          sheldon.setup!
          green "New Sheldon database created at #{abs_data_path}"
        end

        write_to_dotfile("data_directory", sheldon.brain.location)
      end
    end

    desc "version", "Prints the current version of Sheldon"
    def version
      announce ::Sheldon::VERSION
    end

    private

    def announce(message)
      logo = "ðŸ’¥".encode("utf-8")
      puts logo + " Sheldon" + logo + "  #{message}"
    end

    def green(message)
      puts "\e[32m#{message}\e[0m"
    end

    def prompt_user(prompt)
      print(prompt + ": ")
      input = STDIN.gets.chomp.strip
      input.empty? ? nil : input
    end

    def read_from_dotfile(key)
      dotfile = YAML::Store.new(add_home(".sheldon"))
      dotfile.transaction { dotfile[key] }
    end

    def red(message)
      puts "\e[31m#{message}\e[0m"
    end

    def sheldon
      with_exception_handling { @sheldon ||= ::Sheldon.new(sheldon_data_dir) }
    end

    def sheldon_data_dir
      sheldon_data_dir = read_from_dotfile("data_directory") || ENV['SHELDON_DATA_DIR']
      sheldon_data_dir || raise("No configuration found. Please run `sheldon setup`")
    end

    def with_exception_handling(&block)
      yield
    rescue Exception => e
      if options[:debug]
        puts ([e.inspect] + e.backtrace).join("\n")
      else
        red(e.message + "\nUse --debug to print backtrace")
      end
      exit!
    end

    def write_to_dotfile(key, value)
      dotfile = YAML::Store.new(add_home(".sheldon"))
      dotfile.transaction { dotfile[key] = value }
    end

  end
end

CLI::Sheldon.start(ARGV)
