#!/usr/bin/env ruby
require "thor"
require_relative "../lib/sheldon"

module CLI
  class Sheldon < Thor
    map link: :recall
    map ls: :list
    map "-v" => :version
    map "--version" => :version

    desc "build path", "Tell Sheldon to build all config_ files in a directory to single master config"
    def build(rel_path_to_target)
      abs_build_path = File.expand_path(rel_path_to_target)
      with_exception_handling{ sheldon.build(abs_build_path) }
      announce("Built #{File.basename(rel_path_to_target)}")
    end

    desc "forget recall_cue", "Remove file/folder from Sheldon's brain"
    def forget(recall_cue=nil)
      recall_cue ||= prompt_user("Recall Cue For File/Folder")
      with_exception_handling { sheldon.forget(recall_cue) }
      announce("I've forgotten about #{recall_cue}. Let us never mention it again.")
    end

    desc "learn path", "Add a new file/folder to Sheldon's brain. Supply a recall_cue at runtime."
    def learn(rel_path_to_target)
      abs_learn_path = File.expand_path(rel_path_to_target)
      default_cue = File.basename(rel_path_to_target)
      recall_cue = prompt_user("Recall Cue For File/Folder (#{default_cue})") || default_cue
      with_exception_handling { sheldon.learn(recall_cue, abs_learn_path) }
      with_exception_handling { sheldon.recall(recall_cue) }
    end

    desc "list", "List all recall cues known by Sheldon"
    def list
      sheldon.list_cues.each do |recall_cue|
        sheldon.recalled?(recall_cue) ? green(recall_cue) : red(recall_cue)
      end
    end

    desc "recall recall_cue", "Symlink a previously learnt file/directory to it's original location on the filesystem.\nUse `sheldon list` for available cues."
    option :i, type: :boolean, desc: "Interactive mode - prompts Y/N for each available recall_cue"

    def recall(recall_cue=nil)
      if options[:i]
        sheldon.list_cues.each do |recall_cue|
          answer = prompt_user("Recall #{recall_cue}? (Y/N)")
          with_exception_handling { sheldon.recall(recall_cue) if answer.downcase == "y" }
        end
      else
        recall_cue ||= prompt_user("Recall Cue For File/Folder")
        with_exception_handling { sheldon.recall(recall_cue) }
      end

      announce("Recall Complete.")
    end

    desc "setup path_to_data_directory", "Setup Sheldon on this host, supplying the path that where Sheldon's data directory can be found, or should be created."
    def setup(rel_data_path)
      abs_data_path = File.expand_path(rel_data_path)
      with_exception_handling do
        sheldon = ::Sheldon.new(abs_data_path)

        if sheldon.brain.present?
          green "Using existing Sheldon database found at #{abs_data_path}."
        else
          sheldon.setup!
          green "New Sheldon database created at #{abs_data_path}"
        end

        write_to_dotfile("data_directory", sheldon.brain.location)
      end
    end

    desc "version", "Prints the current version of Sheldon"
    def version
      announce ::Sheldon::VERSION
    end

    private

    def sheldon
      with_exception_handling { @sheldon ||= ::Sheldon.new(sheldon_data_dir) }
    end

    def sheldon_data_dir
      sheldon_data_dir = read_from_dotfile("data_directory") || ENV['SHELDON_DATA_DIR']
      sheldon_data_dir || raise("No configuration found. Please run `sheldon setup`")
    end

  end
end

CLI::Sheldon.start(ARGV)
